blueprint:
  name: Advanced Heating Control v4
  author: panhans
  description: "

    ## Core Features

    - heating based on a scheduler, presence of persons and/or presence sensor

    - window open / TRV off

    - party mode

    - guest mode (if nobody is home who activates heating automatically)

    - winter mode: enable / disable the automation itself

    - holiday mode: provide a 2nd holiday scheduler

    - trv calibration by an external temperature sensor

    - several tweaks for fixing your TRV issues


    ## New in version 4

    âœ… Time Based Comfort Temperature Heating Plan

    âœ… switch from number selectors to duration selectors to make timeouts ect. more flexible

    âœ… generic TRV calibration

    âœ… multiple schedulers

    âœ… not mode heat but auto

    âœ… variable (*input_number*) minimum temperature

    âœ… frost protection temp if people not home or presence sensor wasn't on for specific duration

    âœ… aggressive mode

    âœ… custom actions when switching between heat and min
    
    âœ… customizable durations for people leaving / entering home
 
    âŒ make use of HA's proximity integration

    âŒ possibility to pause calibration

    âŒ weather or temperature sensor for winter mode



    ## Additional Information

    **Version**: 4.0_alpha10

    **Help & FAQ**: [Advanced Heating Control](https://community.home-assistant.io/t/advanced-heating-control)

    **Debug Configuration**: `blueprints.panhans.heatingcontrol: debug`



    If you like my work and support feel free to support me.


    [![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/Q5Q3QEH52)

    "
  source_url: https://github.com/panhans/HomeAssistant/blob/dev_v4/blueprints/automation/panhans/heating_control.yaml
  domain: automation
  input:
    input_trvs:
      name: ðŸ”¥ Thermostats / Valves
      description: >
        Thermostats to be controlled.
      selector:
        entity:
          filter:
            - domain:
                - climate
          multiple: true

    input_temperature_minimum_static:
      name: â„ï¸ Static Minimum Temp
      description: >
        The temperature that is set when your heating schedule is not active.
      default: 19
      selector:
        number:
          min: 4.0
          max: 24.0
          step: 0.5
          mode: slider
          unit_of_measurement: Â°C

    input_temperature_minimum:
      name: â„ï¸ðŸŽšï¸ Minimum Temp (optional)
      description: >
        To control your minimum temperature via automations or the UI, you can specify an *input_number* entity here.
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_number
          multiple: false

    # C O M F O R T   &   M O D S
    input_temperature_comfort_static:
      name: â˜€ï¸ Static Comfort Temperature
      description: >
        You can set a static comfort temperature here.
      default: 22
      selector:
        number:
          min: 12.0
          max: 30.0
          step: 0.5
          mode: slider
          unit_of_measurement: Â°C

    input_temperature_comfort:
      name: â˜€ï¸ðŸŽšï¸ Comfort temperature (optional)
      description: >
        To control your comfort temperature via automations or the UI, you can specify an *input_number* entity here.
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_number
          multiple: false

    input_time_based_comfort_change:
      name: ðŸ“ˆ Comfort Heating Plan (optional)
      description: >
        Define you comfort temperature plan. You need to provide an *input_number* for your comfort temperature. Then you can setup a heating plan like this:

        ```yaml

        - time: "08:00"
          temp: "22"
        - time: "16:00"
          temp: "20"
        - time: "20:00"
          temp: "24"
        ```

      selector:
        object:
      default: "[]"

    # P E R S O N S
    input_persons:
      name: ðŸ‘¥ People (optional)
      description: >
        You can specify people to make your heating plan more dynamic. If you do not use schedulers or presence sensors, heating is activated as soon as someone is at home.<br/>
        With schedulers or presence sensors, these are only active when someone is at home.
      default: []
      selector:
        entity:
          filter:
            - domain:
                - person
          multiple: true

    input_people_entering_home_duration:
      name: ðŸ  Enter Home Duration
      description: >
        Duration for which someone must be at home for heating to be activated.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    input_people_leaving_home_duration:
      name: ðŸ’¨ Leaving Home Duration
      description: >
        Duration for which someone must be out of the house for heating to be deactivated.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    # S C H E D U L E R
    input_schedulers:
      name: â²ï¸ Scheduler (optional)
      description: >
        A scheduler specifies when heating to comfort temperature should take place. You can create it in the helper section of Home Assistant.<br/>
        If you have also specified people, someone must also be at home for heating.<br/>
        You can create as many schedulers as you like. Make sure the names are clear.
      default: []
      selector:
        entity:
          filter:
            - domain:
                - schedule
          multiple: true

    input_scheduler_selector:
      name: â˜ðŸ» Scheduler Selector
      description: >
        Define an entity to choose from your schedulers. If you use one scheduler only you can ignore this. If you use more than one scheduler you have multiple possibilities to setup your selection: <br/>

        * toggle (*input_boolean*) or *binary_sensor*: If *off* the first defined scheduler is active. If *on* second scheduler is active. More than 2 schedulers cannot be selected with binary inputs.

        * text (*input_text*), drop down (*input_select*) or sensor:
          * The value has to match the friendly name of the selected scheduler at least partially. Example: If you provide three schedulers called *work*, *holiday/sick*, *guest* you can select the holiday scheduler while setting the selection entity to *sick*, *holiday* or *holiday/sick*. This option is case insensitive.
          * You also can go with numbers: if you want to choose the first scheduler the selector entity must return the number *1*. For the 2nd number *2* and so on.

      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - input_text
                - input_number
                - input_select
          multiple: false

    # P R E S E N C E
    input_presence_sensor:
      name: ðŸš¶ Presence Sensor (optional)
      description: >
        If you specify a presence sensor, heating will take place if it detects presence.<br/>
        If you have specified people, at least one must also be at home.
      default:
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
                - input_boolean
          multiple: false

    input_scheduler_presence:
      name: â²ï¸ Presence Sensor Scheduler (optional)
      description: >
        The presence scheduler specifies exactly when the presence sensor should be used during the day.
      default:
      selector:
        entity:
          filter:
            - domain:
                - schedule
          multiple: false

    input_presence_reaction_on_time:
      name: â³ Presence Reaction On Time
      description: >
        Specify the duration for which the presence sensor must detect any presence so that the comfort temperature is set.
      default:
        hours: 0
        minutes: 5
        seconds: 0
      selector:
        duration:

    input_presence_reaction_off_time:
      name: âŒ› Presence Reaction Off Time
      description: Specify the duration for which the presence sensor must not detect any presence so that the minimum temperature is set.
      default:
        hours: 0
        minutes: 5
        seconds: 0
      selector:
        duration:

    # M O D E S
    input_mode_party:
      name: ðŸŽˆ Party mode (optional)
      description: >
        If on, all settings are ignored and heating takes place.
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - timer
          multiple: false

    input_mode_guest:
      name: ðŸ¤ Guest mode (optional)
      description: >
        If an entity is specified here, it is treated like a person. It's usefull when you're leaving your guests alone in your home and you are not using presence detection.
          
          * entity defined -> person defined
          * enitity is *on* -> simulates person is home
          * enitity is *off* -> simulates person is away

      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - timer
          multiple: false

    # W I N D O W   O P E N   D E T E C T I O N
    input_windows:
      name: ðŸªŸ Windows / Doors (optional)
      description: If open during airing TRVs will be set to *off*.
      default: []
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
          multiple: true

    input_windows_reaction_time:
      name: â³ Window / Door Reaction Time
      description: Duration for which a window or door must be open/closed for the thermostats to close/open.
      default:
        hours: 0
        minutes: 0
        seconds: 30
      selector:
        duration:

    # F R O S T   P R O T E C T I O N
    input_frost_protection_temp:
      name: ðŸ§Š Frost Protection Temperature
      description: >
        You can set the frost protection temperature here.
      default: 5
      selector:
        number:
          min: 5.0
          max: 17.0
          step: 0.5
          mode: slider
          unit_of_measurement: Â°C

    input_frost_protection_duration:
      name: ðŸ§Š Frost Protection Fallback Duration
      description: >
        If the defined persons are not at home for a longer period of time or the presence sensor has no longer detected any presence, the frost protection temperature can be lowered after a this duration.
        Note: If set to zero frost protection temperature never will be set.
      default:
        days: 0
        hours: 0
        minutes: 0
        seconds: 0
      selector:
        duration:
          enable_day: true

    # C A L I B R A T I O N
    input_temperature_sensor:
      name: ðŸŒ¡ï¸ External Temperatur Sensor (optional)
      description: >
        Temperature calibration for your TRVs. The following is supported:

          * TRVs must provide calibration number entity (entity_id must contain *calibration* or *offset*)
          * TADO TRVs
          * generic calibration

        Note: This is an additional sensor inside your room usually next to your favourite spot.
      default:
      selector:
        entity:
          filter:
            - domain:
                - sensor
              device_class:
                - temperature
          multiple: false

    input_calibration_generic:
      name: ðŸ”„ Generic Calibration
      description: >
        If your valves don't support calibration or calibration doesn't work properly enable this option. An offset for every valve depending on your external temperature sensor will be calculated and added to your target temperature.
        Note that the target temperatures of your valves will differ from your minimum or comfort temperature. Also have in mind that the calibration delta has no impact with this option.
      default: false
      selector:
        boolean: {}

    input_calibration_rounding_full_values:
      name: ã€°ï¸ Calibration Full Rounding
      description: >
        Some integrations offer a calibration step size of e.g. *0.1* or *0.01* so theoretically calibration values of e.g. *2.3* or *3.45* are possible.<br/>
        But some TRVs can handle only full values. Just have a look into your devices. Enable this to force rounding to full values in order to prevent redundant calibration calls.
      default: false
      selector:
        boolean: {}

    input_calibration_timeout:
      name: â³ Calibration Timeout
      description: >
        Define a timeout if you want to decrease the amount of calibration calls if temperature changes too much. At least temperature of the external sensor or trv must stay for that duration before calibration gets triggered.
      default:
        hours: 0
        minutes: 1
        seconds: 0
      selector:
        duration:

    input_calibration_delta:
      name: â†”ï¸ Calibration Delta
      description: >
        If the difference between the TRV temperature and the external sensor temperature is greater or less than the calibration delta the TRV calibration will be triggered.<br/>
        The lower the delta the often calibration gets triggered.
      default: 0.5
      selector:
        number:
          min: 0
          max: 2
          step: 0.1
          mode: slider
          unit_of_measurement: Â°C

    # O T H E R    M O D S
    input_mode_winter:
      name: â›„ Winter Mode / Automation Toggle (optional)
      description: >
        If *on* the automation is active. If *off* your valves will set to *off* and the automation is going to sleep.
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
          multiple: false

    input_force_max_temperature:
      name: ðŸ¥µ Force Max Temperature (optional)
      description: >
        Set the maximum temperature of all TRVs regardless of any other settings.
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
          multiple: false

    # M O D I F I E R S

    input_reset_comfort_temperature:
      name: â†©ï¸ Reset Comfort Temperature
      description: >
        After the end of the scheduler, presence detection or a party, you can automatically reset the comfort temperature to the static comfort temperature.<br/>
        If the party ends, this happens immediately. With the normal scheduler or presence detection, this is only carried out if the temperature will set to the minimum temperature.
      default: false
      selector:
        boolean: {}

    input_off_instead_min:
      name: âš™ï¸ Off Instead Of Minimum Temperature
      description: >
        If enabled your climates turn *off* instead of lower temperature to minimum temperature.
      default: false
      selector:
        boolean: {}

    input_force_minimum_temperature:
      name: âš™ï¸ Force Minimum Temperature
      description: >
        Enable this option if you have problems with mode *off*.<br/>
        Instead of set them to *off*, all TRVs will be set to their individual minimum temperature.
      default: false
      selector:
        boolean: {}

    input_not_heat_but_auto:
      name: âš™ï¸ Not Heat But Auto
      description: >
        If mode *Auto* is the common mode of your valves for default heating instead of mode *Heat*.
      default: false
      selector:
        boolean: {}

    input_aggressive_mode:
      name: âš™ï¸ Agressive Mode
      description: >
        Activate this option if your valves react slowly or only start to react at a large temperature difference between actual and set temperature.
        When activated the target temperature of your vavles will set to max or min until it matches the real target temperature +/- 0.5Â°C.
      default: false
      selector:
        boolean: {}

    input_split_service_calls:
      name: âš™ï¸ Split Service Calls
      description: >
        Mode and temperature are set in one service call. Some TRVs have problems by setting it this way.<br/>
        Activate this option to set mode and temperature in separate service calls.
      default: false
      selector:
        boolean: {}

    input_service_call_delay:
      name: âš™ï¸ Service Call Delay
      description: >
        Some TRVs have problems with setting mode and temperature. You can try to increase the
        delay between the service calls. This could fix your problems.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    # C U S T O M   A C T I O N
    input_custom_action:
      name: ðŸŽ¬ Custom Action
      description: >
        This custom action gets executed with every temperature / mode change except calibration. If you want to control other devices just check states before doing a service call.
        Use the variable *is_heating* in your conditions. *True* means heating is active.
      default:
      selector:
        action:

    # E X P E R I M E N T A L
    input_change_comfort_temperature_on_physical_change:
      name: ðŸ§ª Physical Comfort Temperature Change (experimental)
      description: >
        Enable this if you want to control the comfort temperature with your valves. 
        A comfort temperature *input_number* has to be defined. Note that the changes have no effect on the minimum temperature. 
        The temperature for the value range of the *input_number* is also adjusted.

        Note: This feature doesn't work properly since there is a [bug](https://github.com/home-assistant/core/issues/68047) in home assistant.
      default: false
      selector:
        boolean: {}

    input_start_party_timer_on_physical_change:
      name: ðŸ§ª Start Party Timer on Physical Comfort Temperature Change (experimental)
      description: >
        If enabled party mode will be started if a timer is given and temperature changed on a TRV device.
      default: false
      selector:
        boolean: {}

##################################################
############### T R I G G E R ####################
##################################################

trigger_variables:
  # M O D E S
  input_mode_winter: !input input_mode_winter
  input_mode_party: !input input_mode_party
  input_mode_guest: !input input_mode_guest
  input_force_max_temperature: !input input_force_max_temperature

  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_minimum: !input input_temperature_minimum
  input_time_based_comfort_change: !input input_time_based_comfort_change

  # S C H E D U L E R
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector
  input_scheduler_presence: !input input_scheduler_presence

  # A D D I T I O N A L   S E T T I N G S
  input_windows: !input input_windows
  input_temperature_sensor: !input input_temperature_sensor
  input_persons: !input input_persons
  input_presence_sensor: !input input_presence_sensor
  input_calibration_timeout: !input input_calibration_timeout

  input_frost_protection_duration: !input input_frost_protection_duration

trigger:
  # S Y S T E M   T R I G G E R S
  - platform: homeassistant
    event: start
    id: hastart

  - platform: event
    event_type: automation_reloaded

  # S T A T E   T R I G G E R S
  - platform: state
    entity_id: !input input_trvs
    attribute: temperature
    for:
      seconds: 5
    id: comfort_change

  - platform: state
    entity_id: !input input_trvs
    attribute: current_temperature
    for:
      seconds: 5
    id: valve_current_temp_change

  # T E M P E R A T U R E   C H A N G E S
  - platform: template
    value_template: >
      {% if input_temperature_minimum != none %}
        {{ now() - states.input_number[input_temperature_minimum.split('.')[1]].last_updated >= timedelta(seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}

  - platform: template
    value_template: >
      {% if input_temperature_comfort != none %}
        {{ now() - states.input_number[input_temperature_comfort.split('.')[1]].last_updated >= timedelta(seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}

  # S C H E D U L E R   O N / O F F
  - platform: template
    value_template: >
      {% set trigger_state = 'on' %}
      {% set selected_scheduler = '' %}

      {% if input_schedulers | count == 0 %}
        {% set selected_scheduler = '' %}
      {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
        {% set selected_scheduler = input_schedulers[0] %}
      {% elif input_schedulers | count > 1 %}
        {% set selected_scheduler = input_schedulers[0] %}
        {% set selector_value = states(input_scheduler_selector) %}

        {% if is_number(selector_value) %}
          {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
          {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
          {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
        {% elif selector_value in ['on','off'] %}
          {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
        {% else %}
          {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first %}
        {% endif %}

      {% endif %}

      {{ iif(selected_scheduler != '', is_state(selected_scheduler, trigger_state), false) }}

  - platform: template
    id: scheduler-off
    value_template: >
      {% set trigger_state = 'off' %}
      {% set selected_scheduler = '' %}

      {% if input_schedulers | count == 0 %}
        {% set selected_scheduler = '' %}
      {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
        {% set selected_scheduler = input_schedulers[0] %}
      {% elif input_schedulers | count > 1 %}
        {% set selected_scheduler = input_schedulers[0] %}
        {% set selector_value = states(input_scheduler_selector) %}

        {% if is_number(selector_value) %}
          {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
          {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
          {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
        {% elif selector_value in ['on','off'] %}
          {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
        {% else %}
          {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first %}
        {% endif %}

      {% endif %}

      {{ iif(selected_scheduler != '', is_state(selected_scheduler, trigger_state), false) }}

  # P E R S O N  P R E S E N C E
  - platform: template
    value_template: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count > 0 }}"
    for: !input input_people_entering_home_duration

  - platform: template
    value_template: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count == 0 }}"
    id: person-presence-off
    for: !input input_people_leaving_home_duration

  # W I N D O W  O P E N
  - platform: template
    value_template: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count > 0 }}"
    for: !input input_windows_reaction_time

  - platform: template
    value_template: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count == 0 }}"
    for: !input input_windows_reaction_time

  # M O D E   -   W I N T E R
  - platform: template
    value_template: "{{ input_mode_winter != none and is_state(input_mode_winter, 'on') }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_mode_winter != none and is_state(input_mode_winter, 'off') }}"
    for:
      seconds: 2

  # M O D E   -   M A I N T A N A C E
  - platform: template
    value_template: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'on') }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'off') }}"
    for:
      seconds: 2

  # M O D E   -   P A R T Y
  - platform: template
    value_template: "{{ input_mode_party != none and states(input_mode_party) in ['on','active'] }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_mode_party != none and states(input_mode_party) in ['off','idle','paused'] }}"
    id: party-off
    for:
      seconds: 2

  # M O D E   -   G U E S T
  - platform: template
    value_template: "{{ input_mode_guest != none and states(input_mode_guest) in ['on','active'] }}"
    for:
      seconds: 2
  - platform: template
    value_template: "{{ input_mode_guest != none and states(input_mode_guest) in ['off','idle','paused'] }}"
    id: guest-presence-off
    for:
      seconds: 2

  # P R E S E N C E   S E N S O R
  - platform: template
    value_template: "{{ input_presence_sensor != none and is_state(input_presence_sensor, 'on') }}"
    for: !input input_presence_reaction_on_time

  - platform: template
    value_template: "{{ input_presence_sensor != none and is_state(input_presence_sensor, 'off') }}"
    id: sensor-personpresence-off
    for: !input input_presence_reaction_off_time

  # P R E S E N C E   S C H E D U L E R
  - platform: template
    value_template: "{{ input_scheduler_presence != none and is_state(input_scheduler_presence, 'on') }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_scheduler_presence != none and is_state(input_scheduler_presence, 'off') }}"
    for:
      seconds: 2

  # E X T E R N A L  C A L I B R A T I O N   S E N S O R
  - platform: template
    id: "calibration_sensor_temp"
    value_template: >
      {% if input_temperature_sensor != none %}
        {{ (now() - states.sensor[input_temperature_sensor.split('.')[1]].last_updated) >= timedelta(hours=input_calibration_timeout.hours, minutes=input_calibration_timeout.minutes, seconds=input_calibration_timeout.seconds) }}
      {% else %}
        {{ false }}
      {% endif %}

  - platform: state
    id: "calibration_trv_temp"
    entity_id: !input input_trvs
    attribute: current_temperature
    for: !input input_calibration_timeout

  # C O M F O R T   T E M P   C H A N G E   B Y   T I M E
  - platform: template
    id: "comfort_changed_by_time"
    value_template: "{{ now().strftime('%H:%M') in (input_time_based_comfort_change | map(attribute='time') | list) }}"

  # F R O S T   P R O T E C T I O N
  - platform: template
    value_template: >
      {% set is_frost_protection_configured = input_frost_protection_duration.hours | int > 0 or input_frost_protection_duration.minutes | int > 0 or input_frost_protection_duration.seconds | int > 0 %}
      {% set is_frost_protection_configured = iif(is_frost_protection_configured,is_frost_protection_configured,days in input_frost_protection_duration) %}
      {% set is_person_based = input_persons | count > 0 %}
      {% set is_presence_based = input_presence_sensor != none %}

      {% if is_frost_protection_configured == false or ( is_person_based == false and is_presence_based == false ) %}
        {{ false }}
      {% else %}
        {% set person_fp = false %}
        {% set presence_fp = false %}

        {% set delta = timedelta(**input_frost_protection_duration)%}

        {% if is_person_based %}
          {% set last_person_leaving = input_persons | expand | sort(attribute = 'last_changed', reverse=true) | map(attribute='entity_id') | first %}
          {% set person_fp = (now() - states.person[last_person_leaving.split('.')[1]].last_changed) >= delta %}
        {% endif %}

        {% if is_presence_based %}
          {% set presence_fp = (now() - ([input_presence_sensor] | expand | map(attribute='last_changed') | first)) >= delta %}
        {% endif %}

        {% if is_person_based and is_presence_based %}
          {{ person_fp and presence_fp }}
        {% else %}
          {{ iif(is_person_based, person_fp, presence_fp) }}
        {% endif %}
      {% endif %}

##################################################
############### V A R I A B L E S ################
##################################################

variables:
  # I N P U T S
  input_trvs: !input input_trvs
  input_force_minimum_temperature: !input input_force_minimum_temperature
  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_comfort_static: !input input_temperature_comfort_static
  input_temperature_minimum: !input input_temperature_minimum
  input_temperature_minimum_static: !input input_temperature_minimum_static

  #frost protection
  input_frost_protection_temp: !input input_frost_protection_temp
  input_frost_protection_duration: !input input_frost_protection_duration

  # heating scheduler
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector

  input_scheduler_presence: !input input_scheduler_presence

  input_windows: !input input_windows

  input_mode_winter: !input input_mode_winter
  input_mode_party: !input input_mode_party
  input_mode_guest: !input input_mode_guest
  input_force_max_temperature: !input input_force_max_temperature
  input_persons: !input input_persons
  input_presence_sensor: !input input_presence_sensor
  input_presence_reaction_off_time: !input input_presence_reaction_off_time
  input_presence_reaction_on_time: !input input_presence_reaction_on_time
  input_temperature_sensor: !input input_temperature_sensor
  input_split_service_calls: !input input_split_service_calls
  input_calibration_delta: !input input_calibration_delta
  input_off_instead_min: !input input_off_instead_min
  input_change_comfort_temperature_on_physical_change: !input input_change_comfort_temperature_on_physical_change
  input_reset_comfort_temperature: !input input_reset_comfort_temperature
  input_start_party_timer_on_physical_change: !input input_start_party_timer_on_physical_change
  input_calibration_rounding_full_values: !input input_calibration_rounding_full_values
  input_time_based_comfort_change: !input input_time_based_comfort_change
  input_service_call_delay: !input input_service_call_delay
  input_calibration_generic: !input input_calibration_generic
  input_not_heat_but_auto: !input input_not_heat_but_auto
  input_aggressive_mode: !input input_aggressive_mode
  input_custom_action: !input input_custom_action

  # V A L V E   G R O U P S
  valves: "{{ expand(input_trvs) | map(attribute='entity_id') | list }}"
  valves_off_mode: "{{ valves | expand | selectattr('attributes.hvac_modes','search','(?i)off') | map(attribute='entity_id') | list }}"
  valves_without_off_mode: "{{ valves | reject('in',valves_off_mode) | list }}"
  valves_tado: "{{ valves | select('is_device_attr', 'manufacturer', 'Tado') | list }}"

##################################################
########### C O N D I T I O N S ##################
##################################################

condition:
  - condition: or
    conditions:
      - condition: template
        value_template: "{{ trigger.id == 'valve_current_temp_change' and input_aggressive_mode }}"
      - condition: template
        value_template: "{{ trigger.id == 'comfort_change' and input_temperature_comfort != none and trigger.to_state.context.id != none and trigger.to_state.context.parent_id == none and trigger.to_state.context.user_id == none }}"
      - condition: template
        value_template: "{{ trigger.id == 'comfort_change' and input_temperature_comfort != none and trigger.to_state.context.id != none and trigger.to_state.context.parent_id == none and trigger.to_state.context.user_id == none }}"
      - condition: template
        value_template: "{{ (trigger.id == 'calibration_sensor_temp' or trigger.id == 'calibration_trv_temp') and input_temperature_sensor != none }}"
      - condition: template
        value_template: "{{ trigger.id not in ['calibration_sensor_temp','comfort_change','calibration_trv_temp','valve_current_temp_change'] }}"

##################################################
################## A C T I O N ###################
##################################################

action:
  # DELAY AFTER HA START
  - if:
      - condition: trigger
        id: "hastart"
    then:
      - delay:
          seconds: 30

  # SETTING UP VARIABLES
  - variables:
      # S T A T E S
      state_mode_party: "{{ input_mode_party != none and states(input_mode_party) in ['on','active'] }}"
      state_mode_guest: "{{ input_mode_guest != none and states(input_mode_guest) in ['on','active'] }}"
      state_mode_winter: "{{ input_mode_winter == none or (input_mode_winter != none and is_state(input_mode_winter, 'on')) }}"
      state_force_max_temperature: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'on') }}"
      state_window: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count > 0 }}"

      state_temperature_comfort: >
        {% if input_temperature_comfort != none %}
          {{ states(input_temperature_comfort) }}
        {% else %}
          {{ input_temperature_comfort_static }}
        {% endif %}

      active_scheduler: >
        {% set selected_scheduler = none %}

        {% if input_schedulers | count == 0 %}
          {% set selected_scheduler = none %}
        {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
          {% set selected_scheduler = input_schedulers[0] %}
        {% elif input_schedulers | count > 1 %}
          {% set selected_scheduler = input_schedulers[0] %}
          {% set selector_value = states(input_scheduler_selector) %}

          {% if is_number(selector_value) %}
            {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
            {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
            {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
          {% elif selector_value in ['on','off'] %}
            {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
          {% else %}
            {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first %}
          {% endif %}
        {% endif %}

        {{ selected_scheduler }}

      # People Configuration
      is_person_based: "{{ input_mode_guest != none or input_persons | count > 0 }}"
      is_anybody_home: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count > 0 or state_mode_guest }}"

      # Presence Configuration
      is_presence_sensor_defined: "{{ input_presence_sensor != none }}"
      is_presence_scheduler_defined: "{{ input_scheduler_presence != none }}"
      state_presence_sensor: "{{ is_presence_sensor_defined and is_state(input_presence_sensor, 'on') }}"
      state_presence_scheduler: "{{ is_presence_scheduler_defined and is_state(input_scheduler_presence, 'on') }}"

      is_presence_on: >
        {% set result = false %}
        {% if is_presence_sensor_defined %}
          {% set result = iif(is_presence_scheduler_defined, state_presence_scheduler and state_presence_sensor, state_presence_sensor) %}
        {% endif %}
        {{ iif(is_person_based, result and is_anybody_home, result) }}

      # Scheduler Configuration
      is_scheduled_heating: "{{ active_scheduler != none }}"
      state_scheduler: "{{ is_scheduled_heating and is_state(active_scheduler,'on') }}"

      is_scheduled_heating_on: >
        {{ iif(is_person_based, state_scheduler and is_anybody_home, state_scheduler) }}

      is_frost_protection: >
        {% set is_frost_protection_configured = input_frost_protection_duration.hours | int > 0 or input_frost_protection_duration.minutes | int > 0 or input_frost_protection_duration.seconds | int > 0 %}
        {% set is_frost_protection_configured = iif(is_frost_protection_configured,is_frost_protection_configured,days in input_frost_protection_duration) %}
        {% set is_person_based = input_persons | count > 0 %}
        {% set is_presence_based = input_presence_sensor != none %}

        {% if is_frost_protection_configured == false or ( is_person_based == false and is_presence_based == false ) %}
          {{ false }}
        {% else %}
          {% set person_fp = false %}
          {% set presence_fp = false %}

          {% set delta = timedelta(**input_frost_protection_duration)%}

          {% if is_person_based %}
            {% set last_person_leaving = input_persons | expand | sort(attribute = 'last_changed', reverse=true) | map(attribute='entity_id') | first %}
            {% set person_fp = (now() - states.person[last_person_leaving.split('.')[1]].last_changed) >= delta %}
          {% endif %}

          {% if is_presence_based %}
            {% set presence_fp = (now() - ([input_presence_sensor] | expand | map(attribute='last_changed') | first)) >= delta %}
          {% endif %}

          {% if is_person_based and is_presence_based %}
            {{ person_fp and presence_fp }}
          {% else %}
            {{ iif(is_person_based, person_fp, presence_fp) }}
          {% endif %}
        {% endif %}

      state_temperature_min: >
        {% if is_frost_protection %}
          {{ input_frost_protection_temp }}
        {% else %}
          {% if input_temperature_minimum != none %}
            {{ states(input_temperature_minimum) }}
          {% else %}
            {{ input_temperature_minimum_static }}
          {% endif %}
        {% endif %}

      # T R V - V A L U E S
      set_comfort: >
        {% if state_mode_party == true %}
          {{ true }}
        {% elif is_person_based and is_presence_sensor_defined == false and is_scheduled_heating == false %}
          {{ is_anybody_home }}
        {% else %}
          {{ is_scheduled_heating_on or is_presence_on }}
        {% endif %}

      mode: >
        {% if ((state_mode_winter == true or state_mode_party == true) and state_window == false) or state_force_max_temperature == true %}
          {% if input_off_instead_min == true and set_comfort == false %}
            off
          {% else %}
            {{ iif(input_not_heat_but_auto,'auto','heat') }}
          {% endif %}
        {% else %}
          off
        {% endif %}

      temperature: "{{ iif(set_comfort, state_temperature_comfort, state_temperature_min) }}"

      is_heating: "{{ set_comfort and mode != 'off' }}"

      trvs_temp_is_none: "{{ expand(input_trvs) | selectattr('attributes.temperature', 'defined') | selectattr('attributes.temperature', 'eq', none) | map(attribute='entity_id') | list }}"
      trvs_temp_not_set: "{{ expand(input_trvs) | selectattr('attributes.temperature', 'defined') | rejectattr('attributes.temperature', 'eq', float(temperature)) | map(attribute='entity_id') | list }}"
      trvs_mode_not_set: "{{ expand(input_trvs) | rejectattr('state', 'eq', mode) | map(attribute='entity_id') | list }}"
      trvs_mode_and_temp_not_set: "{{ (((trvs_temp_not_set + trvs_temp_is_none) | reject('in', trvs_mode_not_set) | list) + trvs_mode_not_set) | list }}"

  - service: system_log.write
    data:
      message: >
        >>> {{" \n "}}
        - active_scheduler: {{ active_scheduler }} {{" \n "}}
        - mode: {{ mode }} {{" \n "}}
        - temperature: {{ temperature }} {{" \n "}}
        - set_comfort: {{ set_comfort }} {{" \n "}}
        - is_frost_protection: {{ is_frost_protection }} {{" \n "}}
        - is_person_based: {{ is_person_based }} {{ " \n " }}
        - is_anybody_home: {{ is_anybody_home }} {{ " \n " }}
        - is_presence_sensor_defined: {{ is_presence_sensor_defined }} {{ " \n " }}
        - is_presence_scheduler_defined {{ is_presence_scheduler_defined }} {{ " \n " }}
        - state_presence_sensor: {{ state_presence_sensor }} {{ " \n " }}
        - state_presence_scheduler: {{ state_presence_scheduler }} {{ " \n " }}
        - is_presence_on: {{ is_presence_on }} {{ " \n " }}
        - is_scheduled_heating: {{ is_scheduled_heating }} {{ " \n " }}
        - state_scheduler: {{ state_scheduler }} {{ " \n " }}
        - is_scheduled_heating_on: {{ is_scheduled_heating_on }} {{ " \n " }}
        - valves_off_mode: {{ valves_off_mode }} {{ " \n " }}
        - valves_without_off_mode: {{ valves_without_off_mode }} {{ " \n " }}
        - valves_tado: {{ valves_tado }} {{ " \n " }}
        - input_frost_protection_duration: {{ input_frost_protection_duration }}
      level: debug
      logger: blueprints.panhans.heatingcontrol

  # ----------------------------------------------------------------------------------------------------------------------------------------------------------
  # A C T I O N S
  - choose:
      # MANUAL COMFORT CHANGE -------------------------------------------------------------------------------------------------------------
      - conditions:
          - condition: template
            value_template: >
              {{ 
                (trigger.id == 'comfort_change' and input_change_comfort_temperature_on_physical_change) or
                trigger.id == 'comfort_changed_by_time'
              }}

          - condition: template
            value_template: "{{ input_temperature_comfort != none }}"

        sequence:
          - variables:
              timestamp: "{{ now().strftime('%H:%M') }}"
              new_manual_temp_r: >
                {% if trigger.id == 'comfort_changed_by_time' %}
                    {{ input_time_based_comfort_change | selectattr("time", "eq", timestamp) | map(attribute='temp') | first | default(state_temperature_comfort) }}
                {% else %}
                  {{ trigger.to_state.attributes.temperature }}
                {% endif %}
              max_comfort_temp_r: "{{ state_attr(input_temperature_comfort,'max') }}"
              min_comfort_temp_r: "{{ state_attr(input_temperature_comfort,'min') }}"
              comfort_change_error: "{{ new_manual_temp_r == none or max_comfort_temp_r == none or min_comfort_temp_r == none}}"

          - service: system_log.write
            data:
              level: debug
              logger: blueprints.panhans.heatingcontrol
              message: >
                new_manual_temp_r: {{ new_manual_temp_r }}
                max_comfort_temp_r: {{ max_comfort_temp_r }}
                min_comfort_temp_r: {{ min_comfort_temp_r }}
                comfort_change_error: {{ comfort_change_error }}
                timestamp: {{ timestamp }}

          - condition: template
            value_template: "{{ comfort_change_error == false }}"

          - variables:
              new_manual_temp: "{{ new_manual_temp_r | float(0) }}"
              max_comfort_temp: "{{ max_comfort_temp_r | float(0) }}"
              min_comfort_temp: "{{ min_comfort_temp_r | float(0) }}"
              real_manual_temp: >
                {% if (new_manual_temp > max_comfort_temp) %}
                  {{ max_comfort_temp }}
                {% elif (new_manual_temp < min_comfort_temp ) %}
                  {{ min_comfort_temp }}
                {% else %}
                  {{ new_manual_temp }}
                {% endif %}
          - if:
              - condition: template
                value_template: "{{ new_manual_temp > max_comfort_temp or new_manual_temp < min_comfort_temp }}"
            then:
              - service: system_log.write
                data:
                  level: warning
                  logger: blueprints.panhans.heatingcontrol
                  message: "{{ input_temperature_comfort }} can handle numbers between {{ min_comfort_temp }} and {{ max_comfort_temp }}. You want to set the temperature to {{ new_manual_temp }} Â°C. So comfort temperature will automatically adjust to {{ real_manual_temp }} Â°C."

          # IF NEW COMFORT TEMP CHANGED -> SET NEW
          - if:
              - condition: template
                value_template: "{{  real_manual_temp != state_temperature_comfort }}"
            then:
              - service: system_log.write
                data:
                  level: debug
                  logger: blueprints.panhans.heatingcontrol
                  message: "Comfort Temperature will set to: {{ real_manual_temp }}"

              - service: input_number.set_value
                data:
                  value: "{{ real_manual_temp }}"
                target:
                  entity_id: !input input_temperature_comfort

          # IF PARTY TIMER IS GIVEN AND PARTY MODE IS OFF AND TIMER SHALL START -> START TIMER
          - if:
              - condition: template
                value_template: "{{ input_start_party_timer_on_physical_change and input_mode_party != none and input_mode_party.split('.')[0] == 'timer' and state_mode_party == false }}"
            then:
              - delay:
                  hours: "{{ input_service_call_delay.hours }}"
                  minutes: "{{ input_service_call_delay.minutes }}"
                  seconds: "{{ input_service_call_delay.seconds }}"
              - service: timer.start
                target:
                  entity_id: "{{ input_mode_party }}"

          - delay:
              hours: "{{ input_service_call_delay.hours }}"
              minutes: "{{ input_service_call_delay.minutes }}"
              seconds: "{{ input_service_call_delay.seconds }}"

      # CALIBRATION -------------------------------------------------------------------------------------------------------------
      - conditions:
          - condition: or
            conditions:
              - condition: trigger
                id: "calibration_trv_temp"
              - condition: trigger
                id: "calibration_sensor_temp"
          - condition: template
            value_template: "{{ input_calibration_generic == false }}"
          - condition: template
            value_template: "{{ mode == 'heat' }}"

        sequence:
          - repeat:
              count: "{{ valves | count | int }}"
              sequence:
                - variables:
                    current_valve: "{{ valves[repeat.index-1] }}"
                    calibration_entity: >
                      {% set entities =  device_entities(device_id(current_valve)) %}
                      {% set calibration_entity_id = namespace(id=[]) %} 
                      {% for s in entities %}
                        {% if (('calibration' in s) or ('offset' in s))  %}
                          {% set calibration_entity_id.id = s %}
                        {% endif %}
                      {% endfor %} 
                      {{ iif (calibration_entity_id.id[0] is defined, calibration_entity_id.id, '')  }}

                - condition: template
                  value_template: "{{ calibration_entity != '' or current_valve in valves_tado or input_calibration_generic }}"

                - variables:
                    offset_old_r: >
                      {% if  calibration_entity != '' %}
                        {{ states(calibration_entity) }}
                      {% else %}
                        {{ state_attr(current_valve, 'offset_celsius') }}
                      {% endif %}
                    actual_sensor_temperature_r: "{{ states(input_temperature_sensor) }}"
                    local_temperature_r: "{{ state_attr(current_valve,'current_temperature') }}"

                    offset_old: "{{ offset_old_r | float(0) }}"
                    actual_sensor_temperature: "{{ actual_sensor_temperature_r | float(0) | round(1) }}"
                    local_temperature: "{{ local_temperature_r | float(0) }}"

                - condition: template
                  value_template: "{{ is_number(offset_old_r) == true and is_number(actual_sensor_temperature_r) == true and is_number(local_temperature_r) == true }}"

                - if:
                    - condition: template
                      value_template: "{{ calibration_entity != '' }}"
                  then:
                    - variables:
                        step_r: "{{ state_attr(calibration_entity,'step') }}"
                        min_calibration_value_r: "{{ state_attr(calibration_entity,'min') }}"
                        max_calibration_value_r: "{{ state_attr(calibration_entity,'max') }}"

                        step: "{{ step_r | float(0) }}"
                        actual_trv_temperature: "{{ float(local_temperature) - (offset_old | float(0)) | round(1) }}"
                        min_calibration_value: "{{ min_calibration_value_r | float(0) }}"
                        max_calibration_value: "{{ max_calibration_value_r | float(0) }}"
                        new_calibration_value: "{{ actual_sensor_temperature - actual_trv_temperature }}"

                        offset_new: >
                          {% if(new_calibration_value > max_calibration_value) %}
                            {% set new_calibration_value = max_calibration_value %}
                          {% elif (new_calibration_value < min_calibration_value) %}
                            {% set new_calibration_value = min_calibration_value %}
                          {% endif %}

                          {% set offset = (new_calibration_value | float(0) / step) | round(0) * step %}
                          {{ iif(input_calibration_rounding_full_values == true, float(offset) | round(), offset) }}

                    - service: system_log.write
                      data:
                        level: debug
                        logger: blueprints.panhans.heatingcontrol
                        message: >
                          Calibration:  {{" \n "}}
                          offset_old: {{ offset_old }}  {{" \n "}}
                          offset_new: {{ offset_new }}  {{" \n "}}
                          step: {{ step }} {{" \n "}}
                          diff: {{ (float(offset_old) - float(offset_new)) | abs }} {{" \n "}}
                          delta: {{ float(input_calibration_delta) }}
                          full_rounding: "{{ input_calibration_rounding_full_values }}"

                    - condition: template
                      value_template: "{{ is_number(step_r) == true and is_number(min_calibration_value_r) and is_number(max_calibration_value_r) == true }}"

                    - condition: template
                      value_template: "{{ (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) }}"

                    - service: system_log.write
                      data:
                        level: debug
                        logger: blueprints.panhans.heatingcontrol
                        message: >
                          Calibration set to:  {{ offset_new }} on {{ calibration_entity }}

                    - service: number.set_value
                      data:
                        value: "{{ float(offset_new) }}"
                      target:
                        entity_id: "{{ calibration_entity }}"

                  # Tado Calibration
                  else:
                    - variables:
                        offset_new: >
                          {% set offset = float(actual_sensor_temperature) - float(local_temperature) %}
                          {% set calculated_offset = ( float(offset) + (offset_old | float(0)) ) | round(2) %}

                          {{ iif(input_calibration_rounding_full_values == true, float(calculated_offset) | round(), calculated_offset) }}

                    - condition: template
                      value_template: "{{ (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) }}"

                    - service: tado.set_climate_temperature_offset
                      data:
                        offset: "{{ offset_new }}"
                        entity_id: "{{ current_valve }}"

                - delay:
                    hours: "{{ input_service_call_delay.hours }}"
                    minutes: "{{ input_service_call_delay.minutes }}"
                    seconds: "{{ input_service_call_delay.seconds }}"

      # AUTO RESET COMFORT TEMP
      - conditions:
          - condition: template
            value_template: "{{  input_temperature_comfort != none and float(states(input_temperature_comfort)) != float(input_temperature_comfort_static) }}"
          - condition: template
            value_template: "{{ (trigger.id in ['party-off'] or (trigger.id in ['scheduler-off','person-presence-off','guest-presence-off','sensor-presence-off'] and set_comfort == false)) and input_reset_comfort_temperature == true }}"
        sequence:
          - service: input_number.set_value
            data:
              value: "{{ input_temperature_comfort_static }}"
            target:
              entity_id: !input input_temperature_comfort

    # SET MODE & TEMPERRATURE -------------------------------------------------------------------------------------------------------------
    default:
      - if:
          - condition: template
            value_template: "{{ mode == 'off' }}"
        then:
          # SET TEMPERATURE TO MINIMUM INSTEAD TO MODE OFF
          - if:
              - condition: template
                value_template: "{{ input_force_minimum_temperature or valves_without_off_mode | count > 0 }}"
            then:
              - variables:
                  low_temp_valves: "{{ iif(input_force_minimum_temperature == true, valves, valves_without_off_mode) }}"
              - repeat:
                  count: "{{ low_temp_valves | count | int }}"
                  sequence:
                    - variables:
                        current_valve: "{{ low_temp_valves[repeat.index-1] }}"
                        off_temperature: "{{ state_attr(current_valve,'min_temp') }}"
                        temperature: "{{ state_attr(current_valve,'temperature') }}"
                    - if:
                        - condition: template
                          value_template: "{{ temperature != off_temperature }}"
                      then:
                        - service: climate.set_temperature
                          data:
                            entity_id: "{{ current_valve }}"
                            temperature: "{{ off_temperature | float }}"
                        - delay:
                            hours: "{{ input_service_call_delay.hours }}"
                            minutes: "{{ input_service_call_delay.minutes }}"
                            seconds: "{{ input_service_call_delay.seconds }}"

            # SET MODE TO OFF AND NOT MIN TEMP
            else:
              - if:
                  - condition: template
                    value_template: "{{ valves_off_mode | count > 0 }}"
                  - condition: template
                    value_template: "{{ input_force_minimum_temperature == false }}"
                then:
                  if:
                    - condition: template
                      value_template: "{{ trvs_mode_not_set | count > 0 }}"
                  then:
                    - variables:
                        valves_to_turn_off: "{{ (valves_off_mode | select('in', trvs_mode_not_set) | list) }}"
                    - if:
                        - condition: template
                          value_template: "{{ input_split_service_calls == true }}"
                      then:
                        - repeat:
                            count: "{{ valves_to_turn_off | count | int }}"
                            sequence:
                              - variables:
                                  current_valve: "{{ valves_to_turn_off[repeat.index-1] }}"
                              - service: climate.set_hvac_mode
                                target:
                                  entity_id: "{{ current_valve }}"
                                data:
                                  hvac_mode: "off"
                              - delay:
                                  hours: "{{ input_service_call_delay.hours }}"
                                  minutes: "{{ input_service_call_delay.minutes }}"
                                  seconds: "{{ input_service_call_delay.seconds }}"
                      else:
                        - service: climate.set_hvac_mode
                          target:
                            entity_id: "{{ (valves_off_mode | select('in', trvs_mode_not_set) | list)}}"
                          data:
                            hvac_mode: "off"
                        - delay:
                            hours: "{{ input_service_call_delay.hours }}"
                            minutes: "{{ input_service_call_delay.minutes }}"
                            seconds: "{{ input_service_call_delay.seconds }}"

        # IF NOT OFF -> HEAT
        else:
          - if:
              - condition: template
                value_template: "{{ state_force_max_temperature or input_split_service_calls or input_calibration_generic or input_aggressive_mode }}"
            # FORCE MAX TEMP
            then:
              - variables:
                  valves_to_be_set: "{{ iif(state_force_max_temperature or input_calibration_generic or input_aggressive_mode, valves, trvs_mode_and_temp_not_set) }}"
              - repeat:
                  count: "{{ valves_to_be_set | count | int }}"
                  sequence:
                    - variables:
                        current_valve: "{{ valves_to_be_set[repeat.index-1] }}"
                        current_valve_temp: "{{ state_attr(current_valve,'current_temperature') }}"
                        step: "{{ state_attr(current_valve,'target_temp_step') | float(0.5) }}"
                        sensor_temp: >
                          {% if input_temperature_sensor != none %}
                            {{ states(input_temperature_sensor) }}
                          {% else %}
                            {{ current_valve_temp }}
                          {% endif %}
                        min_temp_r: "{{ state_attr(current_valve,'min_temp') }}"
                        max_temp_r: "{{ state_attr(current_valve,'max_temp') }}"
                        new_temperature: >
                          {% if state_force_max_temperature %}
                            {{ state_attr(current_valve,'max_temp') }}
                          {% elif input_calibration_generic and current_valve_temp != sensor_temp %}
                            {% set offset = sensor_temp | float(0) - current_valve_temp | float(0) %}
                            {% set temp_with_offset = float(temperature) - float(offset) %}

                            {% set min_temp = min_temp_r | float(0) %}
                            {% set max_temp = max_temp_r | float(0) %}

                            {% set temp_with_offset = (temp_with_offset | float(0) / float(step)) | round(0) * float(step) %}

                            {% if(temp_with_offset > max_temp) %}
                              {% set temp_with_offset = max_temp %}
                            {% elif (temp_with_offset < min_temp) %}
                              {% set temp_with_offset = min_temp %}
                            {% endif %}

                            {{ iif(input_calibration_rounding_full_values == true, float(temp_with_offset) | round(), temp_with_offset) }}

                          {% else %}
                            {{ temperature }}
                          {% endif %}

                    - service: system_log.write
                      data:
                        message: >
                          {{" \n "}}
                          - generic calibration enabled: {{ input_calibration_generic }} {{" \n "}}
                          - current_valve_temp: {{ current_valve_temp }} {{" \n "}}
                          - sensor_temp: {{sensor_temp }} {{" \n "}}
                          - step: {{ step }} {{" \n "}}
                          - min_temp_r: {{ min_temp_r }} {{" \n "}}
                          - max_temp_r: {{ max_temp_r }} {{" \n "}}
                          - new_temperature: {{ new_temperature }} {{" \n "}}
                          - temp_without_offset: {{ temperature }}
                        level: debug
                        logger: blueprints.panhans.heatingcontrol

                    # AGGRESSIVE MODE
                    - variables:
                        new_temperature: >
                          {% if input_aggressive_mode %}
                              {% set temp_diff = current_valve_temp - new_temperature %}
                              {% if temp_diff < -0.5 %}
                                {{ max_temp_r }}
                              {% elif temp_diff > 0.5 %}
                                {{ min_temp_r }}
                              {% else %}
                                {{ new_temperature }}
                              {% endif %}
                          {% else %}
                            {{ new_temperature }}
                          {% endif %}

                    - condition: template
                      value_template: >
                        {{ input_calibration_generic == false or 
                          ( 
                            is_number(current_valve_temp) and 
                            is_number(sensor_temp) and 
                            is_number(min_temp_r) and 
                            is_number(max_temp_r)
                          ) 
                        }}

                    - if:
                        - condition: template
                          value_template: "{{ states(current_valve) != mode }}"
                      then:
                        - service: climate.set_hvac_mode
                          target:
                            entity_id: "{{ current_valve }}"
                          data:
                            hvac_mode: "{{ mode }}"
                        - delay:
                            hours: "{{ input_service_call_delay.hours }}"
                            minutes: "{{ input_service_call_delay.minutes }}"
                            seconds: "{{ input_service_call_delay.seconds }}"
                    - if:
                        - condition: template
                          value_template: "{{ state_attr(current_valve, 'temperature') != new_temperature }}"
                      then:
                        - service: climate.set_temperature
                          data:
                            entity_id: "{{ current_valve }}"
                            temperature: "{{ new_temperature | float }}"
                        - delay:
                            hours: "{{ input_service_call_delay.hours }}"
                            minutes: "{{ input_service_call_delay.minutes }}"
                            seconds: "{{ input_service_call_delay.seconds }}"

                    - variables:
                        temperature: "{{ new_temperature }}"
            else:
              - if:
                  - condition: template
                    value_template: "{{ trvs_mode_not_set | count > 0 }}"
                then:
                  - service: climate.set_hvac_mode
                    target:
                      entity_id: "{{ trvs_mode_not_set }}"
                    data:
                      hvac_mode: "{{ mode }}"
                  - delay:
                      hours: "{{ input_service_call_delay.hours }}"
                      minutes: "{{ input_service_call_delay.minutes }}"
                      seconds: "{{ input_service_call_delay.seconds }}"
              - if:
                  - condition: template
                    value_template: "{{ trvs_temp_not_set | count > 0 }}"
                then:
                  - service: climate.set_temperature
                    data:
                      entity_id: "{{ trvs_temp_not_set }}"
                      temperature: "{{ temperature | float }}"
                  - delay:
                      hours: "{{ input_service_call_delay.hours }}"
                      minutes: "{{ input_service_call_delay.minutes }}"
                      seconds: "{{ input_service_call_delay.seconds }}"

          # variables: mode, temperature, set_comfort
          - if:
              - condition: template
                value_template: "{{ input_custom_action != none }}"
            then: !input "input_custom_action"

mode: queued
